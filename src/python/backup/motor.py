#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

import sys
import zmq
import time
import math
import signal
from collections import deque
from threading import Thread
import flatbuffers
#generated by flatc
import topics.motor.command
import topics.motor.value
#PWM library
from Adafruit_BBIO import PWM

class Subscriber(Thread):
    def __init__(self, context, id, topics_callbacks):
        super().__init__()
        self.context = context
        self.topics_callbacks = topics_callbacks
        self.loop = False

    def run(self):
        print('starting subscriber, on topic(s) {}'.format(self.topics_callbacks.keys()))
        subscriber = self.context.socket(zmq.SUB)
        subscriber.connect("tcp://127.0.0.1:5555")
        for topic in self.topics_callbacks.keys():
            subscriber.setsockopt_string(zmq.SUBSCRIBE, topic)
        poller = zmq.Poller()
        poller.register(subscriber, zmq.POLLIN)
        self.loop = True
        while self.loop:
            evts = poller.poll(1000)
            if evts:
                message = subscriber.recv()
                for topic in self.topics_callbacks.keys():
                    topic_name_msg = message.split(None,1)
                    topic_name = topic_name_msg[0]
                    topic_msg = topic_name_msg[1]
                    if topic == topic_name.decode('utf-8'):
                        self.topics_callbacks[topic](topic_msg)

    def stop(self):
        self.loop = False

class Publisher:
    def __init__(self):
        signal.signal(signal.SIGINT, self.exit_signal)
        self.zmq_context = zmq.Context()
        self.setup_subscriber()
        #setup flatbuffers
        self.fb_builder = flatbuffers.Builder(1024)
        self.motor_command_msg = None
        self.motor_1_command = 0.0
        self.motor_2_command = 0.0
        self.motor_3_command = 0.0
        #setup motors
        self.pwm_freq = 8000.0                                                  #8000 Hz max for BlueRobotics ESC
        self.pwm_stop = 1500                                                    #motor esc stops at 1500 microseconds
        PWM.start("P9_21", self.pwm_stop/(1e6/self.pwm_freq), self.pwm_freq)    #motor 1 beaglebone PWM pin
        PWM.start("P9_22", self.pwm_stop/(1e6/self.pwm_freq), self.pwm_freq)    #motor 2 beaglebone PWM pin
        PWM.start("P9_16", self.pwm_stop/(1e6/self.pwm_freq), self.pwm_freq)    #motor 3 beaglebone PWM pin
        #check BlueRobotics website for current draw - https://bluerobotics.com/store/thrusters/t100-t200-thrusters/t200-thruster/
        #limit ourselves to ~6.5A
        self.pwm_min = 1275                                                     #max reverse microseconds pwm value
        self.pwm_max = 1725                                                     #max forward microseconds pwm value
        self.pwm_deadband = 40                                                  #deadband around 1500 microseconds of 40 microseconds
        self.command_min = -80.0
        self.command_max = 80.0
        self.command_deadband = 2.0
        time.sleep(10.0)

    def exit_signal(self, sig, frame):
        print('You pressed Ctrl+C!')
        PWM.stop("P9_21")
        PWM.stop("P9_22")
        PWM.stop("P9_16")
        PWM.cleanup()
        sys.exit(0)

    def setup_subscriber(self):
        self.subscriber = Subscriber(self.zmq_context, 0, {'motor.command':self.motor_command_callback})
        self.subscriber.start()

    def motor_command_callback(self, msg):
        self.motor_command_msg = topics.motor.command.command.GetRootAscommand(msg, 0)
        self.motor_1_command = self.motor_command_msg.Motor1Command()
        self.motor_2_command = self.motor_command_msg.Motor2Command()
        self.motor_3_command = self.motor_command_msg.Motor3Command()

    def map_command_to_pwm(self, command):
        if abs(command) <= self.command_deadband:                               #stop vehicle if command is within command deadband
            return self.pwm_stop/(1e6/self.pwm_freq)
        else:
            command_scale = (command - self.command_min)/(self.command_max - self.command_min)
            min_val = self.pwm_min/(1e6/self.pwm_freq)
            max_val = self.pwm_max/(1e6/self.pwm_freq)
            pwm_val = command_scale*(max_val - min_val) + min_val
            pwm_val_us = pwm_val*(1e6/self.pwm_freq)
            if abs(pwm_val_us - self.pwm_stop) <= self.pwm_deadband:            #if pwm mapping is within pwm deadband, push outside pwm deadband
                if abs(pwm_val_us - (self.pwm_stop - self.pwm_deadband)) < abs(pwm_val_us - (self.pwm_stop + self.pwm_deadband)):
                    pwm_val = (self.pwm_stop-40)/(1e6/self.pwm_freq)
                else:
                    pwm_val = (self.pwm_stop+40)/(1e6/self.pwm_freq)
            return pwm_val

    def run(self):
        socket = self.zmq_context.socket(zmq.PUB)
        socket.connect("tcp://127.0.0.1:5556")

        count = 0
        while True:
            count += 1

            topics.motor.value.valueStart(self.fb_builder)
            topics.motor.value.valueAddTime(self.fb_builder, time.time())

            #limit motor commands and map to pwm values
            if self.motor_1_command < self.command_min:
                self.motor_1_command = self.command_min
            if self.motor_1_command > self.command_max:
                self.motor_1_command = self.command_max
            motor_1_pwm = self.map_command_to_pwm(self.motor_1_command)
            topics.motor.value.valueAddMotor1Value(self.fb_builder, motor_1_pwm)
            if self.motor_2_command < self.command_min:
                self.motor_2_command = self.command_min
            if self.motor_2_command > self.command_max:
                self.motor_2_command = self.command_max
            motor_2_pwm = self.map_command_to_pwm(self.motor_2_command)
            topics.motor.value.valueAddMotor2Value(self.fb_builder, motor_2_pwm)
            if self.motor_3_command < self.command_min:
                self.motor_3_command = self.command_min
            if self.motor_3_command > self.command_max:
                self.motor_3_command = self.command_max
            motor_3_pwm = self.map_command_to_pwm(self.motor_3_command)
            topics.motor.value.valueAddMotor3Value(self.fb_builder, motor_3_pwm)

            #set duty cycles
            PWM.set_duty_cycle("P9_21", motor_1_pwm)
            PWM.set_duty_cycle("P9_22", motor_2_pwm)
            PWM.set_duty_cycle("P9_16", motor_3_pwm)

            value_msg = topics.motor.value.valueEnd(self.fb_builder)
            self.fb_builder.Finish(value_msg)
            bin_value_msg = self.fb_builder.Output()
            socket.send(b'motor.value' + b' ' + bin_value_msg)
            print(motor_1_pwm)
            print(motor_2_pwm)
            print(motor_3_pwm)
            print('')
            time.sleep(.1)

if __name__ == "__main__":
    pub = Publisher()
    pub.run()
